{
  "projects": [
    {
      "id": "replay-platformer",
      "title": "Replay Platformer",
      "tagline": "A 3D platformer with tight movement mechanics and accessibility options.",
      "description": "A 3D platformer featuring tight movement mechanics and accessibility options. Playable with both controller and keyboard, including a web version for easy access.\n\nI thoroughly enjoyed developing this game, focusing heavily on game feel and visual polish to ensure the movement felt satisfying and responsive. Implementing the wall jump mechanics presented an interesting challenge, but it was rewarding to perfect.\n\nThis project sparked my passion for creating advanced movement systems, and I look forward to exploring more complex mechanics in future projects.",
      "thumbnail": "/Portofolio-Website/Imgs/replay-platformer-gameplay.gif",
      "youtube": "",
      "screenshots": [
        "/Portofolio-Website/Imgs/replay-platformer-screenshot.png",
        "/Portofolio-Website/Imgs/replay-platformer-extra-1.png",
        "/Portofolio-Website/Imgs/replay-platformer-extra-2.png",
        "/Portofolio-Website/Imgs/replay-platformer-extra-3.png"
      ],
      "tags": [
        "Unity",
        "C#",
        "3D",
        "Platformer",
        "Puzzle"
      ],
      "projectRole": "Gameplay Programmer",
      "timeline": "3 weeks",
      "mechanics": [
        {
          "subtitle": "Wall Jump - Detection",
          "description": "The system constantly checks for walls using raycasts. This allows the player to slide down walls and prepare for a jump. We check for collision on both sides to determine the wall direction.",
          "image": "/Portofolio-Website/Imgs/replay-code-walljump-1.png",
          "code": "bool IsTouchingWall()\n{\n    return Physics2D.Raycast(transform.position, wallDir, wallCheckDist, wallLayer);\n}"
        },
        {
          "subtitle": "Wall Jump - Execution",
          "description": "When jumping from a wall, we apply force in the opposite direction and upwards. This creates a satisfying arc that allows players to climb vertical shafts or bounce between walls.",
          "image": "/Portofolio-Website/Imgs/replay-code-walljump-2.png",
          "code": "void PerformWallJump()\n{\n    rb.velocity = new Vector2(-wallDir * jumpForce.x, jumpForce.y);\n    isWallJumping = true;\n}"
        },
        {
          "subtitle": "Enemy FSM - Base State",
          "description": "I implemented a flexible Finite State Machine for enemy AI. The base state defines the contract (Enter, Update, Exit) that all specific behavior states must implement.",
          "image": "/Portofolio-Website/Imgs/replay-code-enemy-1.png",
          "code": "public abstract class EnemyState\n{\n    protected Enemy enemy;\n    public abstract void Enter();\n    public abstract void Update();\n    public abstract void Exit();\n}"
        },
        {
          "subtitle": "Enemy FSM - Chase Logic",
          "description": "In the Chase state, these enemies navigate the platforming environment to reach the player. They can jump over gaps and track the player's position efficiently.",
          "image": "/Portofolio-Website/Imgs/replay-code-enemy-2.png",
          "code": "public class ChaseState : EnemyState\n{\n    public override void Update()\n    {\n        enemy.MoveTowards(target.position);\n        if (enemy.IsinAttackRange())\n            enemy.ChangeState(new AttackState());\n    }\n}"
        },
        {
          "subtitle": "Enemy FSM - Attack Behavior",
          "description": "The Attack state handles the combat logic. It triggers animations, deals damage, and creates a cooldown window before the enemy can pursue or attack again.",
          "image": "/Portofolio-Website/Imgs/replay-code-enemy-3.png",
          "code": "public class AttackState : EnemyState\n{\n    public override void Enter()\n    {\n        enemy.animator.SetTrigger(\"Attack\");\n        enemy.StartCoroutine(AttackCooldown());\n    }\n}"
        }
      ],
      "git": "",
      "itch": ""
    },
    {
      "id": "vr-shooter",
      "title": "VR Shooter",
      "tagline": "An immersive VR shooter with realistic weapon handling and enemy AI.",
      "description": "VR Shooter is an action-packed virtual reality shooter that focuses on realistic weapon mechanics and engaging combat. Players use motion controllers to physically aim, reload, and fire various weapons while facing waves of intelligent enemies.\n\nThis was my second favorite project because it combined the excitement of VR interaction with challenging technical problems like realistic weapon physics, two-handed weapon handling, and performance optimization for VR. The feeling of physically reloading a weapon in VR is incredibly satisfying.\n\nI focused on making every interaction feel natural and responsive, from grabbing weapons to ejecting magazines. The project taught me about VR-specific design patterns, haptic feedback, and how to maintain smooth performance in VR environments.",
      "thumbnail": "https://picsum.photos/seed/vrshooter/1200/600",
      "youtube": "",
      "screenshots": [
        "https://picsum.photos/seed/vrs1/1200/800",
        "https://picsum.photos/seed/vrs2/1200/800",
        "https://picsum.photos/seed/vrs3/1200/800"
      ],
      "tags": [
        "Unity",
        "VR",
        "XR Toolkit",
        "Shooter",
        "Physics"
      ],
      "projectRole": "VR Developer",
      "timeline": "4 weeks",
      "mechanics": [
        {
          "subtitle": "Two-Handed Weapon System",
          "description": "Weapons can be held with one or two hands for improved stability and accuracy. When grabbing a weapon with the second hand, the weapon's recoil is reduced and aim steadiness increases. The system tracks both controller positions and rotations to calculate the proper weapon orientation. Releasing the secondary hand smoothly transitions back to one-handed mode.",
          "image": "https://picsum.photos/seed/weapon1/1200/800",
          "code": "void UpdateTwoHandedGrip()\n{\n    if (secondaryHand != null)\n    {\n        Vector3 direction = secondaryHand.position - primaryHand.position;\n        transform.rotation = Quaternion.LookRotation(direction);\n        recoilMultiplier = 0.5f;\n    }\n}"
        },
        {
          "subtitle": "Physical Reload Mechanics",
          "description": "Reloading requires physical actions: press a button to eject the magazine, grab a new magazine from your belt, and insert it into the weapon. Each step has proper collision detection and haptic feedback. The magazine socket uses a snap zone that guides the player's hand when the magazine is close enough, making the reload feel smooth and satisfying.",
          "image": "https://picsum.photos/seed/weapon2/1200/800",
          "code": "void OnMagazineInserted(Magazine mag)\n{\n    currentMagazine = mag;\n    ammoCount = mag.ammoCapacity;\n    PlayHapticFeedback(0.3f);\n    audioSource.PlayOneShot(reloadSound);\n}"
        }
      ],
      "git": "",
      "itch": ""
    },
    {
      "id": "vr-winkel",
      "title": "VR Winkel",
      "tagline": "A virtual reality shopping experience with realistic product interactions.",
      "description": "VR Winkel (VR Shop) is a virtual reality shopping simulation that allows users to browse products, pick them up, examine them, and add items to their cart in an immersive 3D environment. The goal was to create a natural shopping experience that feels intuitive and engaging.\n\nThe project focused on realistic object manipulation, UI design in 3D space, and creating a comfortable VR experience that users can navigate without motion sickness. I implemented various interaction methods including direct grab, ray-based selection, and physical shopping cart mechanics.\n\nThis project taught me about VR UX design, spatial UI placement, and how to balance realism with usability in virtual environments.",
      "thumbnail": "https://picsum.photos/seed/vrshop/1200/600",
      "youtube": "",
      "screenshots": [
        "https://picsum.photos/seed/shop1/1200/800",
        "https://picsum.photos/seed/shop2/1200/800"
      ],
      "tags": [
        "Unity",
        "VR",
        "XR Toolkit",
        "Simulation",
        "UI/UX"
      ],
      "projectRole": "VR Developer",
      "timeline": "2 weeks",
      "mechanics": [
        {
          "subtitle": "Product Interaction System",
          "description": "Products can be picked up, rotated, and examined from all angles using natural hand movements. When holding a product, an information panel appears showing details like price, description, and features. The system uses physics-based interactions so products feel like they have realistic weight and can be placed back on shelves naturally.",
          "image": "https://picsum.photos/seed/product1/1200/800",
          "code": "void OnProductGrabbed(Product product)\n{\n    ShowProductInfo(product);\n    ApplyPhysicsProperties(product);\n    EnableHighlight(product, true);\n}"
        },
        {
          "subtitle": "Shopping Cart Mechanics",
          "description": "The shopping cart follows the player and can be pushed or pulled using the handles. Items can be dropped into the cart, which uses trigger zones to detect when products are added. The cart maintains a list of items and displays the total price on a floating UI panel. Products snap to organized positions inside the cart to prevent clutter.",
          "image": "https://picsum.photos/seed/cart1/1200/800",
          "code": "void OnItemAddedToCart(Product item)\n{\n    cartItems.Add(item);\n    totalPrice += item.price;\n    UpdateCartUI();\n    SnapItemToCartPosition(item);\n}"
        }
      ],
      "git": "",
      "itch": ""
    },
    {
      "id": "invasion",
      "title": "Invasion",
      "tagline": "A wave-based defense game where you protect your base from alien invaders.",
      "description": "Invasion is a wave-based defense game where players must protect their base from increasingly difficult waves of alien enemies. Players can build defensive structures, upgrade weapons, and strategically position themselves to survive as long as possible.\n\nThe project focused on enemy AI, wave progression systems, and resource management. Each wave introduces new enemy types with different behaviors and abilities, requiring players to adapt their strategy. The difficulty curve was carefully balanced through extensive playtesting.\n\nI learned about enemy spawning systems, difficulty scaling, and how to create satisfying progression that keeps players engaged through multiple waves.",
      "thumbnail": "https://picsum.photos/seed/invasion/1200/600",
      "youtube": "",
      "screenshots": [
        "https://picsum.photos/seed/inv1/1200/800",
        "https://picsum.photos/seed/inv2/1200/800"
      ],
      "tags": [
        "Unity",
        "C#",
        "Tower Defense",
        "AI",
        "Strategy"
      ],
      "projectRole": "Gameplay Programmer",
      "timeline": "3 weeks",
      "mechanics": [
        {
          "subtitle": "Wave Spawning System",
          "description": "Enemies spawn in waves with increasing difficulty. Each wave has a configuration that defines enemy types, spawn count, and spawn intervals. The system uses spawn points around the map perimeter and balances spawns to prevent overwhelming one side. Between waves, players get a brief preparation period to build defenses and reposition.",
          "image": "https://picsum.photos/seed/wave1/1200/800",
          "code": "void SpawnWave(WaveConfig wave)\n{\n    for (int i = 0; i < wave.enemyCount; i++)\n    {\n        SpawnPoint point = GetRandomSpawnPoint();\n        Enemy enemy = Instantiate(wave.enemyPrefab, point.position);\n        yield return new WaitForSeconds(wave.spawnInterval);\n    }\n}"
        },
        {
          "subtitle": "Enemy AI Pathfinding",
          "description": "Enemies use NavMesh pathfinding to navigate around obstacles and find the shortest path to the base. Different enemy types have varying speeds and behaviors - some rush directly while others take cover and advance tactically. When enemies reach the base, they attack it until destroyed or the base is destroyed.",
          "image": "https://picsum.photos/seed/enemy1/1200/800",
          "code": "void UpdateAI()\n{\n    if (target != null)\n    {\n        agent.SetDestination(target.position);\n        \n        if (Vector3.Distance(transform.position, target.position) < attackRange)\n        {\n            Attack();\n        }\n    }\n}"
        }
      ],
      "git": "",
      "itch": ""
    }
  ]
}